const MonthlyEvaluation = require("../models/MonthlyEvaluation");
const QuarterlyEvaluation = require("../models/QuarterlyEvaluation");
const AuditLog = require("../models/AuditLog");
const MonthlyAchievement = require("../models/MonthlyAchievement");

// 1. Submit Monthly Evaluation
exports.submitMonthlyEvaluation = async (req, res) => {
  try {
    const { employeeId, monthlyPlanId, month, score, remarks } = req.body;

    const evaluation = await MonthlyEvaluation.create({
      employeeId,
      monthlyPlanId,
      raId: req.user.userId,
      month,
      score,
      remarks
    });

    await AuditLog.create({
      userId: req.user.userId,
      action: "EVALUATE",
      entityType: "MONTHLY_EVALUATION",
      entityId: evaluation._id,
      ipAddress: req.ip
    });

    res.status(201).json({ message: "Monthly evaluation submitted" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// 2. Generate Quarterly Evaluation
exports.generateQuarterlyEvaluation = async (req, res) => {
  try {
    const { employeeId, quarter, months } = req.body;
    // months = ["2026-01", "2026-02", "2026-03"]

    const evaluations = await MonthlyEvaluation.find({
      employeeId,
      month: { $in: months }
    });

    if (evaluations.length === 0) {
      return res.status(400).json({ message: "No monthly evaluations found" });
    }

    const totalScore = evaluations.reduce(
      (sum, evaluation) => sum + evaluation.score,
      0
    );  

    const averageScore = totalScore / evaluations.length;

    const quarterly = await QuarterlyEvaluation.create({
      employeeId,
      quarter,
      raId: req.user.userId,
      averageScore
    });

    await AuditLog.create({
      userId: req.user.userId,
      action: "GENERATE",
      entityType: "QUARTERLY_EVALUATION",
      entityId: quarterly._id,
      ipAddress: req.ip
    });

    res.json({
      message: "Quarterly evaluation generated",
      averageScore
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// 3. Get Monthly Evaluations (THE FIXED VERSION)
exports.getMonthlyEvaluations = async (req, res) => {
  try {
    let filter = {};
    let projection = {};

    // ðŸ” EMPLOYEE: hide marks & remarks
    if (req.user.role === "EMPLOYEE") {
      filter.employeeId = req.user.userId;
      projection = { score: 0, remarks: 0, raId: 0 };
    }

    // ðŸ§‘â€âš–ï¸ RA: only own evaluations
    if (req.user.role === "RA") {
      filter.raId = req.user.userId;
    }

    if (req.query.employeeId && req.user.role !== "EMPLOYEE") {
      filter.employeeId = req.query.employeeId;
    }

    if (req.query.month) {
      filter.month = req.query.month;
    }

    const evaluations = await MonthlyEvaluation.find(filter, projection)
      .populate("employeeId", "name employeeCode department")
      .populate("monthlyPlanId", "month")
      .populate("monthlyAchievementId")
      .sort({ createdAt: -1 });

    // INDUSTRY FIX: Use Promise.all to check Achievement collection directly
    const enrichedEvaluations = await Promise.all(evaluations.map(async (ev) => {
      
      // Double-check: If the ID is missing in the evaluation, look it up manually
      let isAchievementSubmitted = !!ev.monthlyAchievementId;
      
      if (!isAchievementSubmitted && ev.employeeId) {
         const exists = await MonthlyAchievement.exists({
             employeeId: ev.employeeId._id,
             month: ev.month
         });
         isAchievementSubmitted = !!exists;
      }

      return {
        _id: ev._id,
        employeeId: ev.employeeId,
        month: ev.month,

        // âœ… Plan status
        planSubmitted: !!ev.monthlyPlanId,

        // âœ… Achievement status (Robust Check)
        achievementSubmitted: isAchievementSubmitted,

        // âœ… Evaluation
        score: ev.score || null,
        status: ev.score ? "Evaluated" : "Pending"
      };
    }));

    res.json(enrichedEvaluations);
  } catch (error) {
    console.error(error);
    res.status(500).json({
      message: "Failed to fetch monthly evaluations"
    });
  }
};

// 4. Get Quarterly Evaluations
exports.getQuarterlyEvaluations = async (req, res) => {
  try {
    let filter = {};
    let projection = {};

    // ðŸ” EMPLOYEE: only existence, no score
    if (req.user.role === "EMPLOYEE") {
      filter.employeeId = req.user.userId;
      projection = { averageScore: 0, raId: 0 };
    }

    // ðŸ§‘â€âš–ï¸ RA: only evaluations generated by them
    if (req.user.role === "RA") {
      filter.raId = req.user.userId;
    }

    // ðŸ‘” HRD / MD filters
    if (req.query.employeeId && req.user.role !== "EMPLOYEE") {
      filter.employeeId = req.query.employeeId;
    }

    if (req.query.quarter) {
      filter.quarter = req.query.quarter;
    }

    const evaluations = await QuarterlyEvaluation.find(filter, projection)
      .populate("employeeId", "name employeeCode department")
      .populate(
        req.user.role === "EMPLOYEE" ? "" : "raId",
        "name employeeCode"
      )
      .sort({ generatedAt: -1 });

    res.json(evaluations);
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch quarterly evaluations"
    });
  }
};
// Get Monthly Evaluation By ID (VIEW / EVALUATE)
exports.getMonthlyEvaluationById = async (req, res) => {
  try {
    const evaluation = await MonthlyEvaluation.findById(req.params.id)
      .populate("employeeId", "name employeeCode department")
      .populate("monthlyPlanId") // full plan document
      .populate("raId", "name employeeCode");

    if (!evaluation) {
      return res.status(404).json({ message: "Evaluation not found" });
    }

    // Fetch monthly achievement (separate collection)
    const achievement = await MonthlyAchievement.findOne({
      employeeId: evaluation.employeeId._id,
      month: evaluation.month
    });

    res.json({
      evaluation,
      plan: evaluation.monthlyPlanId || null,
      achievement: achievement || null,
      status: {
        planSubmitted: !!evaluation.monthlyPlanId,
        achievementSubmitted: !!achievement,
        evaluated: !!evaluation.score
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch monthly evaluation",
      error: error.message
    });
  }
};
